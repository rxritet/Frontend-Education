# AI_REPORT
## Отчёт об использовании AI

---

## 1. ИНФОРМАЦИЯ ОБ ИСПОЛЬЗОВАНИИ AI

| Поле | Значение |
|---|---|
| **ФИО студента** | Абраев Радмир |
| **Номер группы** | _________________ |
| **Номер лабораторной работы** | Lab_06 |
| **Дата заполнения** | 21.02.2026 |

**AI инструмент:**
- [x] Другой: **Perplexity AI**

**Версия/дата использования:** Perplexity AI (Claude Sonnet 4.6), 2026-02-21

---

## 2. КОНКРЕТНЫЕ ВОПРОСЫ/ПРОМПТЫ

> ВАЖНО: AI использовался ТОЛЬКО как консультант (вопросы, объяснения),
> НЕ для генерации кода. Весь код был написан мной вручную.

---

### Промпт 1

**Вопрос:**
Объясни разницу между `createBrowserRouter` и старым `BrowserRouter` в
react-router-dom v6. Почему в новой версии используют объект конфигурации
вместо JSX-дерева?

**Что получил:**
- [x] Объяснение концепции
- [x] Объяснение синтаксиса

**Краткое описание ответа AI:**
Perplexity объяснил, что `createBrowserRouter` принимает массив объектов
маршрутов с полями `path` и `element`, что позволяет разделить объявление
роутов по модулям (feature-based). Также объяснил, почему `RouterProvider`
оборачивает приложение вместо `BrowserRouter`. Я использовал это объяснение,
чтобы правильно структурировать `main.tsx` — сначала объявить роутер отдельно,
затем передать его в `<RouterProvider router={router} />`.

---

### Промпт 2

**Вопрос:**
Как работает `<Outlet />` в Layout-компоненте? Я не понимаю, почему
дочерние роуты рендерятся именно там, а не на уровне роутера.

**Что получил:**
- [x] Объяснение концепции
- [x] Пример использования

**Краткое описание ответа AI:**
AI объяснил, что `<Outlet />` — это placeholder: React Router находит
совпавший дочерний маршрут и рендерит его компонент именно в том месте DOM,
где стоит `<Outlet />`. Родительский Layout при этом остаётся неизменным
(навбар и футер не перерисовываются). После этого объяснения я написал
`Layout.tsx` самостоятельно: добавил `<nav>` с `<NavLink>`, `<main>` с
`<Outlet />` и `<footer>`.

---

### Промпт 3

**Вопрос:**
Зачем нужен `loader` в роуте? Чем он отличается от `useEffect` + fetch
внутри компонента?

**Что получил:**
- [x] Объяснение концепции
- [x] Рекомендации

**Краткое описание ответа AI:**
Perplexity объяснил, что `loader` запускается **до** рендеринга компонента,
что исключает промежуточный пустой UI. При использовании `useEffect` компонент
сначала рендерится без данных, потом делает запрос. Также объяснил, что
