AI_REPORT
Отчет об использовании AI

ВАЖНО: Если вы использовали AI (даже как консультанта), этот отчет обязателен.
Отсутствие отчета = -100 баллов (академическая нечестность).

═══════════════════════════════════════════════════════════════
1. ИНФОРМАЦИЯ ОБ ИСПОЛЬЗОВАНИИ AI
═══════════════════════════════════════════════════════════════

ФИО студента:          Абраев Радмир
Номер группы:          ___________________________
Номер лабораторной:    Lab_07
Дата заполнения:       28.02.2026

AI инструмент (отметьте):
[✓] Perplexity AI
[ ] ChatGPT (OpenAI)
[ ] GitHub Copilot
[ ] Microsoft Copilot
[ ] Claude (Anthropic)
[ ] Другой: _________________

Версия/дата использования: Perplexity Pro (Sonnet 4.6), 2026-02-28

═══════════════════════════════════════════════════════════════
2. КОНКРЕТНЫЕ ВОПРОСЫ / ПРОМПТЫ
═══════════════════════════════════════════════════════════════

ВАЖНО: AI использовался ТОЛЬКО как консультант (вопросы, объяснения),
НЕ для генерации кода. Весь код был написан вами вручную.

---
Вопрос / Промпт 1:
---
Вопрос: "Что такое code splitting в React и зачем нужен lazy()? Объясни
концепцию простыми словами."

Что получил:
[✓] Объяснение концепции
[✓] Объяснение синтаксиса
[ ] Пример использования
[ ] Рекомендации

Краткое описание ответа AI:
Perplexity объяснил, что code splitting — это разбиение бандла приложения
на небольшие чанки, которые загружаются по требованию (on demand), а не
все сразу при первом открытии страницы. lazy() — это функция React, которая
принимает динамический import() и возвращает компонент, который загружается
только при первом рендере. Я понял разницу между статическим и динамическим
импортом и почему это ускоряет начальную загрузку.

---
Вопрос / Промпт 2:
---
Вопрос: "Как работает компонент Suspense? Что такое fallback и когда он
показывается?"

Что получил:
[✓] Объяснение концепции
[✓] Объяснение синтаксиса
[ ] Пример использования
[ ] Рекомендации

Краткое описание ответа AI:
AI объяснил, что Suspense — это компонент-обёртка, который "приостанавливает"
рендеринг дочерних компонентов, пока они загружаются. Пока идёт загрузка,
отображается fallback-контент (например, спиннер или текст "Loading...").
Я понял, что lazy-компоненты обязательно должны быть обёрнуты в Suspense,
иначе будет ошибка.

---
Вопрос / Промпт 3:
---
Вопрос: "Что такое Error Boundary в React? Почему он должен быть class
component, а не функциональным?"

Что получил:
[✓] Объяснение концепции
[✓] Объяснение синтаксиса
[ ] Пример использования
[✓] Рекомендации

Краткое описание ответа AI:
Perplexity объяснил, что Error Boundary — это class-компонент, который
перехватывает JavaScript-ошибки в дереве дочерних компонентов и показывает
fallback UI вместо краша всего приложения. Функциональные компоненты не могут
быть Error Boundary, потому что для этого нужны lifecycle-методы
getDerivedStateFromError и componentDidCatch, которые есть только у классовых
компонентов. Также AI уточнил, что Error Boundary не перехватывает ошибки в
обработчиках событий и асинхронном коде.

---
Вопрос / Промпт 4:
---
Вопрос: "Как добавить функцию retry (повторной попытки) в Error Boundary?
Как сбросить состояние hasError?"

Что получил:
[ ] Объяснение концепции
[✓] Объяснение синтаксиса
[ ] Пример использования
[✓] Рекомендации

Краткое описание ответа AI:
AI объяснил принцип: чтобы сбросить ошибку, нужно вызвать setState({ hasError: false }),
что заставит компонент заново попытаться отрендерить children. Я понял, что
метод resetError нужно привязать как arrow function класса, чтобы корректно
работал this. После объяснения я самостоятельно написал метод resetError и
добавил кнопку "Try Again" в render().

═══════════════════════════════════════════════════════════════
3. ПРОЦЕСС НАПИСАНИЯ КОДА
═══════════════════════════════════════════════════════════════

КРИТИЧЕСКИ ВАЖНО: Весь код написан МНОЙ вручную. AI использовался
ТОЛЬКО для объяснений концепций.

Пошаговый процесс:

Шаг 1. Создал проект через Vite:
  npm create vite@latest lazy-app -- --template react-ts
  Установил зависимости: npm install react-router-dom

Шаг 2. Изучил концепцию code splitting через вопросы к AI (Промпт 1).
  После объяснений самостоятельно написал lazy-импорты в App.tsx.
  Проверил, что каждый lazy() оборачивает динамический import().

Шаг 3. Создал три страницы: Dashboard.tsx, Settings.tsx, Profile.tsx.
  Каждый компонент написал вручную — простой JSX с заголовком и
  описанием страницы.

Шаг 4. Добавил навигацию через react-router-dom: <BrowserRouter>,
  <Routes>, <Route>, <Link>. Уточнил у AI про Suspense (Промпт 2)
  и написал компонент LoadingSpinner с CSS-анимацией спиннера вручную.

Шаг 5. Столкнулся с проблемой: при первом запуске спиннер не отображался,
  потому что забыл обернуть <Routes> в <Suspense>. Нашёл ошибку сам,
  перечитав объяснение AI про порядок оборачивания компонентов.

Шаг 6. Для task2 создал ErrorBoundary.tsx. Спросил у AI про retry (Промпт 4).
  После объяснения самостоятельно написал class ErrorBoundary с методами
  getDerivedStateFromError, componentDidCatch и resetError.

Шаг 7. Обновил App.tsx — добавил <ErrorBoundary> как внешнюю обёртку
  вокруг <Suspense>. Написал компонент ErrorFallback.

Шаг 8. Тестировал: проверил переходы между страницами, убедился что
  спиннер появляется. Для теста Error Boundary временно добавил throw
  new Error() в один из компонентов — fallback UI отобразился корректно.

Шаг 9. Проверил tsconfig.json — убедился что "strict": true включён.
  Убрал все неявные any, добавил типы везде явно.

Шаг 10. Сделал git коммиты с конвенциональными сообщениями, создал README.

═══════════════════════════════════════════════════════════════
4. ЧТО Я УЗНАЛ
═══════════════════════════════════════════════════════════════

Минимум 3 пункта:

1. Понял, как code splitting разбивает бандл на чанки и почему это
   ускоряет начальную загрузку приложения — пользователь скачивает
   только код той страницы, на которой находится.

2. Разобрался в механизме React Suspense: компонент "приостанавливает"
   рендер и показывает fallback, пока Promise от lazy() не resolv-ится.

3. Научился создавать Error Boundary как class component с lifecycle-
   методами getDerivedStateFromError и componentDidCatch, понял ограничения:
   не перехватывает ошибки в event handlers и async коде.

4. Разобрался с паттерном retry в классовых компонентах React —
   setState({ hasError: false }) сбрасывает ошибку и запускает
   повторный рендер children.

5. Закрепил TypeScript strict mode: научился правильно типизировать
   Props и State интерфейсы для class components без использования any.

═══════════════════════════════════════════════════════════════
5. ПРОЦЕНТ ИСПОЛЬЗОВАНИЯ AI
═══════════════════════════════════════════════════════════════

Оцените, насколько AI помог вам как консультант:

[ ] 0-25%  (AI помог только с базовыми объяснениями концепций)
[ ] 26-50% (AI помог понять несколько концепций, я написал весь код сам)
[✓] 51-75% (AI помог с несколькими сложными концепциями, я применил их
            при написании кода)
[ ] 76-100% (AI помог с множеством концепций, но весь код написан мной)

Ваш выбор: 60%

Пояснение:
AI помог мне понять 4 ключевые концепции: code splitting, lazy(), Suspense
и Error Boundary. Без этих объяснений я бы потратил намного больше времени
на чтение документации. Однако весь код — структуру компонентов, JSX,
TypeScript-интерфейсы, CSS-анимацию спиннера — я написал полностью
самостоятельно вручную в OquLabs. AI не генерировал готовый код,
я использовал его только для понимания принципов работы.

═══════════════════════════════════════════════════════════════
ЧЕК-ЛИСТ ПЕРЕД ОТПРАВКОЙ
═══════════════════════════════════════════════════════════════

[✓] Шаблон скачан из Teams
[✓] Отчет заполнен вручную в документе (напечатан, не скопирован)
[✓] НЕ использовался AI для генерации отчета
[✓] Описан весь процесс работы с AI
[✓] Указан AI инструмент (Perplexity AI)
[✓] Вставлены все вопросы/промпты (4 промпта)
[✓] Детально описано использование объяснений AI при написании кода
[✓] Подтверждено, что весь код написан вручную
[✓] Написано, чему я научился (5 пунктов)
[✓] Указан процент использования AI (60%)
[✓] Отчет соответствует процессу в OquLabs сессии
[✓] Документ готов к загрузке в OquLabs